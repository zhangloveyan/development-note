# 部署运维实践

---
tags: [Docker, Linux, 运维, 部署, 权限管理, 网络配置]
created: 2026-02-21
updated: 2026-02-21
status: 持续更新
importance: ⭐⭐⭐⭐⭐
---

## 🎯 核心要点
> 生产环境 Docker 和 Linux 运维的实战经验

- **Docker Compose v2**：避免版本兼容问题
- **用户权限模型**：正确的 Linux 权限管理
- **容器权限**：解决 Docker 权限和文件归属问题
- **网络配置**：容器间通信和端口映射

## 🐳 Docker 环境配置

### Docker Compose 版本问题（重点）

#### ❌ 常见问题
- `KeyError: 'ContainerConfig'`
- build 成功，`up/recreate` 失败
- legacy builder deprecated 提示

#### 🎯 根本原因
- 使用 **docker-compose v1（1.29.x，Python 版，已废弃）**
- Docker Engine/BuildKit 已升级
- v1 与新镜像 metadata **不兼容**

#### ✅ 生产环境推荐方案

**使用 Docker Compose v2（插件版）**：
```bash
# 正确命令格式（注意空格）
docker compose up -d
docker compose down
docker compose logs -f
```

**安装 Docker Compose v2**：
```bash
# 使用 ubuntu 用户，不要切 root
mkdir -p ~/.docker/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.25.0/docker-compose-linux-x86_64 \
  -o ~/.docker/cli-plugins/docker-compose
chmod +x ~/.docker/cli-plugins/docker-compose

# 验证安装
docker compose version
```

**注意事项**：
- `version:` 字段在 compose v2 中已废弃
- 不影响运行，但建议删除

## 👤 Linux 用户权限模型

### 权限管理铁律
> **谁执行命令，谁就必须对文件有权限**

### ✅ 推荐用户模型（生产标准）

| 项目 | 推荐配置 | 说明 |
|------|----------|------|
| 登录用户 | ubuntu | 避免直接使用 root |
| 日常操作 | ubuntu | 保持一致性 |
| 系统级操作 | sudo | 临时提权 |
| 项目目录 owner | ubuntu | 确保操作权限 |
| docker 命令 | 不用 sudo | 加入 docker 组 |

### 推荐目录结构
```bash
# 项目目录
/home/ubuntu/projects/xxx
# 或
/opt/xxx  # owner 必须是 ubuntu
```

### ❌ 不推荐的做法
```bash
# 长期使用 root 用户
sudo su
# 用 root 干一整天活

# 项目目录归 root 所有
chown -R root:root /opt/project
```

## 🔐 Docker 权限配置

### Docker daemon 权限

#### ❌ 常见错误
```text
permission denied while trying to connect to the Docker daemon socket
/var/run/docker.sock
```

#### 🎯 原因分析
- ubuntu 用户不在 docker 组
- docker.sock 权限：`srw-rw---- root docker`

#### ✅ 正确修复（一次性配置）
```bash
# 将 ubuntu 用户加入 docker 组
sudo usermod -aG docker ubuntu

# 必须重新登录生效
exit

# 验证配置
docker ps
groups  # 应该看到 docker 组
```

### 容器内用户权限

#### 🎯 核心认知
> **容器在宿主机创建文件，用的是容器内进程的 UID/GID**

与执行 docker 命令的用户（ubuntu/root）**无关**。

#### ❌ 默认灾难场景
| 项目 | 结果 | 问题 |
|------|------|------|
| 容器用户 | root (UID 0) | 宿主机文件归 root |
| 使用 volume | 是 | ubuntu 无法操作 |
| 宿主机文件 | root:root | permission denied |

#### ✅ 生产推荐方案

**方案 A（最佳）：容器使用非 root 用户**
```dockerfile
# 创建与宿主机 ubuntu 用户对应的用户
RUN groupadd -g 1000 app && \
    useradd -u 1000 -g app -m app

# 切换到非 root 用户
USER app

# 设置工作目录权限
WORKDIR /app
RUN chown -R app:app /app
```

**方案 B（快捷）：compose 指定 user**
```yaml
services:
  app:
    image: your-app
    user: "1000:1000"  # ubuntu 用户的 UID:GID
    volumes:
      - ./data:/app/data
```

**方案 C（运行时）：指定用户运行**
```bash
docker run --user 1000:1000 -v ./data:/app/data your-app
```

## 📁 Volume 挂载规范

### 挂载规则（必背）

| 宿主机 | 容器内 | 是否允许 | 说明 |
|--------|--------|----------|------|
| 文件 | 文件 | ✅ | 配置文件挂载 |
| 目录 | 目录 | ✅ | 数据目录挂载 |
| 文件 | 目录 | ❌ | 类型不匹配 |
| 目录 | 文件 | ❌ | 类型不匹配 |

### ❌ 典型错误
```text
not a directory
Are you trying to mount a directory onto a file (or vice-versa)?
```

### ✅ 生产标准做法

**永远优先挂目录，不挂单文件**：
```yaml
volumes:
  # ✅ 推荐：挂载目录
  - /opt/project/config:/app/config
  - /opt/project/data:/app/data
  - /opt/project/logs:/app/logs

  # ❌ 避免：挂载单文件（除非必要）
  - /opt/project/app.conf:/app/app.conf
```

**配置文件处理方案**：
```yaml
# 方案1：配置目录挂载
volumes:
  - ./config:/app/config

# 方案2：使用 configs（Docker Swarm）
configs:
  app_config:
    file: ./app.conf
services:
  app:
    configs:
      - source: app_config
        target: /app/app.conf
```

## 📂 文件传输最佳实践

### SFTP 传输规则

#### 🎯 重要事实
- SFTP 会话身份 = 登录用户（ubuntu）
- `sudo su` **不会改变 SFTP 身份**
- root 用户无法直接拖拽文件（正常现象）

#### ✅ 正确文件传输流程

1. **上传到用户目录**：
```bash
# FinalShell/WinSCP 拖拽到
/home/ubuntu/
```

2. **移动到目标位置**：
```bash
# 移动文件
sudo mv ~/uploaded_file /opt/project/

# 修改所有者
sudo chown -R ubuntu:ubuntu /opt/project/

# 设置权限
chmod -R 755 /opt/project/
```

3. **批量处理脚本**：
```bash
#!/bin/bash
# deploy.sh
sudo mv ~/app.jar /opt/myapp/
sudo chown ubuntu:ubuntu /opt/myapp/app.jar
sudo systemctl restart myapp
```

## 🌐 Docker 网络配置

### 容器间通信

#### ❌ 常见问题
```text
Connection refused
Name or service not known
```

#### 🎯 原因分析
- 容器不在同一个 docker network
- 使用了 localhost/127.0.0.1

#### ✅ 正确网络配置

**创建自定义网络**：
```yaml
networks:
  app-network:
    driver: bridge

services:
  api:
    networks:
      - app-network

  database:
    networks:
      - app-network

  redis:
    networks:
      - app-network
```

**容器间访问方式**：
```bash
# ✅ 使用服务名访问
curl http://api:8080/health
redis-cli -h redis -p 6379

# ✅ 使用宿主机内网 IP
curl http://172.17.0.1:8080/health

# ❌ 不要使用
curl http://localhost:8080/health
curl http://127.0.0.1:8080/health
```

### 端口映射问题

#### 排查顺序
1. **容器是否监听 0.0.0.0**
```bash
# 检查容器内端口监听
docker exec container_name netstat -tlnp
```

2. **compose ports 配置**
```yaml
services:
  app:
    ports:
      - "8080:8080"  # 宿主机:容器
    # 确保应用监听 0.0.0.0:8080，不是 127.0.0.1:8080
```

3. **云服务器安全组**
- 检查防火墙规则
- 确认端口已开放

## 🔧 SSH 连接问题

### SSH 密钥变更问题

#### ❌ 常见错误
```text
The server key has changed. Either you are under attack or the administrator changed the key.
New server key hash: f3:d6:7e:73:85:e7:b6:9b:be:fe:00:58:21:ff:54:66:0a:1b:0c:00
```

#### 🎯 原因分析
- 服务器 SSH 主机密钥发生变化
- 客户端保存的指纹与当前不匹配
- 安全机制防止中间人攻击

#### ✅ 解决方案

**方案1：删除旧密钥**
```bash
# 删除 known_hosts 中的旧记录
ssh-keygen -R server_ip

# 重新连接
ssh user@server_ip
```

**方案2：Navicat 等工具**
- 删除保存的 SSH 连接配置
- 重新创建连接
- 接受新的主机密钥

## 📋 生产环境检查清单

### 一次配置，长期不踩坑

```text
☑️ ubuntu 用户登录
☑️ ubuntu 加入 docker 组
☑️ 使用 docker compose v2
☑️ 项目目录归 ubuntu 所有
☑️ 容器不使用 root 用户
☑️ volume 只挂载目录
☑️ 容器通过服务名通信
☑️ SSH 权限配置正确
☑️ 安全组端口已开放
☑️ 应用监听 0.0.0.0
```

### 运维口诀（建议贴墙上）

> **不用 sudo 跑 docker**
> **不用 root 跑容器**
> **不单挂文件**
> **不用 compose v1**
> **容器不连 localhost**

## 🔗 相关文档
- **容器技术**：[[08-docker.md]]
- **项目问题**：[[06-项目实战/项目问题总结.md]]
- **开发工具**：[[07-工具环境/IDEA使用技巧.md]]

## 🏷️ 标签
#Docker #Linux #运维 #部署 #权限管理 #网络配置 #生产环境