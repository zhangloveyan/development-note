## 基础

### 1. 数据类型

整数 tinyint(1byte(字节 8bit) 2^8 0-255(unsigned ))、int(4byte)、bigint(8btye)

> bigint(M) 数据宽度，补零 M取值范围0-255

浮点数 float(4byte)、double(8byte)

> float(M,D) M精度、D标度  M(0-255)=整数位+小数位 D(0-30)=小数位
>
> float(5,2) -999.99~999.99

定点数 decimal 底层字符串存储 存储空间=M+2位

> decimal(M,D) M精度、D标度  M(0-65)=整数位+小数位 D(0-30)=小数位 
>
> decimal(5,2) -999.99~999.99

日期 year、date、time、datetime、timestamp

```sql
where 日期 可选用 >,< 或 between and
过滤时，不写时间，默认 0 点'2023-7-29 00:00:00'
查询某一天：time >= '2023-07-27' AND time < '2023-07-28'
如果需要其他格式，可使用 Date 获取日期 DATE_FORMAT(time,'%Y%m%d %H%i%s') 获取指定格式
```

字符 varchar、char、text、longtext

> char(M) M字节
>
> varchar(M) M+1字节 因为长度可变需要额外1个字节记录长度

其他 枚举、二进制 blob 图片等、json

> out of range value for column 'f1' at row x 数据超了范围

### 2. 关键字

character set 字符集 utf-8mb4 4位长度

primary key 主键

auto_increment 自增

unsigned 无符号

### 3. 视图、存储过程、函数

不常用

### 4. mysql8.0

#### 4.1 窗口函数

将范围统计的数据，放在没一行上，对比 group 只返回一行数据

```mysql
SELECT
	*,
	SUM( NO ) over () a1,
	SUM( NO ) over ( PARTITION BY `name` ) a2
FROM
	`user`
```

![image-20230731160143592](.\pic\image-20230731160143592.png)

over() 默认全部 和 group 相同

PARTITION BY name 根据 name 进行分别汇总

#### 4.2 公用表表达式

## 高级

### 1. 逻辑架构

**服务器处理请求过程**

![image-20230801095132905](pic\image-20230801095132905.png)

![image-20230801145110308](pic\image-20230801145110308.png)

**连接池**

> 创建一个连接池队列用于存放和数据库的连接，让访问数据库的客户端可以直接在队列中选取一个可用的连接去访问数据库，用完之后的连接不是被释放掉而是归还给了连接池队列，这样下一个客户端在访问数据库是还可以复用该连接，省去了每一条连接从TCP三次握手建立连接到MYSQL Server的连接认证和MYSQLServer关闭连接回收资源以及四次挥手所消耗的时间。

druid 连接池设置

```shell
url：数据库URL，格式为jdbc:xxx://host:port/database?connection_properties。
username：数据库用户名。
password：数据库密码。
initialSize：连接池初始大小，默认为0。
maxActive：连接池最大连接数，默认为8。
minIdle：连接池最小空闲连接数，默认为0。
maxWait：获取连接的最大等待时间，单位毫秒，默认为-1，表示永不超时。
testWhileIdle：连接空闲时是否进行检测，默认为false。
validationQuery：用于检测连接是否有效的SQL语句，默认为SELECT 1。
testOnBorrow：获取连接时是否进行检测，默认为false。
testOnReturn：归还连接时是否进行检测，默认为false。
poolPreparedStatements：是否缓存PreparedStatement，默认为false。
maxOpenPreparedStatements：缓存的PreparedStatement的最大数量，默认为-1，表示不限制。
filters：拦截器，用于防止SQL注入等问题，默认为空。
```

连接参数设置

```shell
1.最大连接数（max_connections）：允许同时连接到 MySQL 数据库的最大连接数，一般设置为 500-1000。
2.tcp积压请求栈大小（back_log）：相当于线程的队列外的队列，推荐小于512，最大不超900
3.线程池大小（thread_pool_size）：连接线程池的大小，一般设置为 CPU 核数的 2 倍。
4.日志大小（innodb_log_file_size）：InnoDB 存储引擎的日志大小，一般设置为 1GB-2GB。
5.日志缓存大小（innodb_log_buffer_size）：InnoDB 存储引擎的日志缓存大小，一般设置为 32MB-64MB。
6.最大事务数（innodb_max_dirty_pages_pct）：InnoDB 存储引擎的最大事务数，一般设置为 70%-80%。
```

查看 mysql 线程池`SHOW GLOBAL STATUS LIKE 'Thread%'` 当发生下面情况时，需要增加thread_pool_size 大小

![image-20230810205636978](pic\image-20230810205636978.png)

缓冲参数设置

```shell
1.缓冲池大小（innodb_buffer_pool_size）：InnoDB 存储引擎缓存的数据和索引的大小，一般设置为物理内存的 60%-80%。
2.缓存索引大小（key_buffer_size）：线程共享，存储引擎缓存索引数据的大小，一般设置为物理内存的 10%。
3.同时打开表的个数（table_cache）：默认2402，调到 512-1024最佳，同时打开多影响性能
4.查询缓冲区大小（query_cache_size）：在mysql控制台观察，
	Qcache_lowmeme_prunes 值非常大，则表明缓冲不够。需要增加
	Qcache_hits 值非常大，则查询缓冲使用非常频繁，小影响效率
	Qcache_free_blocks 值非常大，则缓冲区碎片多。8.0失效
5.query_cache_type 是 0 时，不使用缓冲
```

文章参考 ：https://blog.csdn.net/weixin_45937536/article/details/122560631

### 2.sql 执行流程

![img](https://img-blog.csdnimg.cn/d4d2a807dc1d4991af28a565f3dbc1a7.png)

#### 2.1 解析器

![img](https://img-blog.csdnimg.cn/67592eeaec7f47289638847e27b764a3.png)

#### 2.2 优化器

**逻辑查询优化**：条件表达式进行等价谓词重写，条件简化，对视图重写，对子查询优化，对连接语义进行外连接消除，嵌套连接消除等

**物理查询优化**：物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划

#### 2.3 执行器

调用存储引擎API对表进行读写，存储引擎API只是抽象接口，下面还有个存储引擎层，具体实现需要看存储引擎层

#### 2.4 select 执行顺序

```mysql
(7) select
(8) distinct <select_list>
(1) from <left_table>
(3) <join_type> join <right_table>
(2) on <join_condition>
(4) where <where_condition>
(5) group by <group_by_list>
(6) having <having_condition>
(9) order by <order_by_condition>
(10) limit <limit_number>
```

1. FROM：对 FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表 VT1。
2. ON：对 VT1 应用 ON 筛选器，只有那些使为真才被插入到 TV2。
3. OUTER (JOIN):如果指定了 OUTER JOIN(相对于 CROSS JOIN 或 INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到 VT2，生成 TV3。如果 FROM 子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤 1 到步骤 3，直到处理完所有的表位置。
4. WHERE：对 TV3 应用 WHERE 筛选器，只有使为 true 的行才插入 TV4。
5. GROUP BY：按 GROUP BY 子句中的列列表对 TV4 中的行进行分组，生成 TV5。
6. CUTE|ROLLUP：把超组插入 VT5，生成 VT6。
7. HAVING：对 VT6 应用 HAVING 筛选器，只有使为 true 的组插入到 VT7。
8. SELECT：处理 SELECT 列表，产生 VT8。
9. DISTINCT：将重复的行从 VT8 中删除，产品 VT9。
10. ORDER BY：将 VT9 中的行按 ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。
11. TOP：从 VC10 的开始处选择指定数量或比例的行，生成表 TV11，并返回给调用者。

### 3. 存储引擎

查看引擎：

```mysql
SHOW VARIABLES LIKE '%storage%'
```

**InnoDB、MyISAM**区别：

InnoDB 支持**事务**、外键、行级锁、聚簇索引（数据在子节点）

MyISAM 非聚簇索引、只支持表级锁、不支持事务、外键，占用空间小，处理速度快

大量写入 InnoDB 最优，读写多更新删除少、原子性不高选 MyISAM

![image-20230801181552656](pic\image-20230801181552656.png)

### 4.索引

### 5.性能分析

**查看系统性能参数**

```mysql
SHOW STATUS LIKE '参数';
connections：连接mysql服务器的次数。
uptime：mysql服务器的上线时间。
slow_queries：慢查询的次数。
innodb_rows_read：select查询返回的行数
innodb_rows_inserted：执行insert操作插入的行数
innodb_rows_updated：执行update操作更新的行数
innodb_rows_deleted：执行delete操作删除的行数
com_select：查询操作的次数。
com_insert：插入操作的次数。对于批量插入的insert操作，只累加一次。
com_update：更新操作 的次数。
com_delete：删除操作的次数。
```

**慢查询日志**

```mysq
-- 查询
SHOW VARIABLES LIKE '%slow_query_log%';
-- 开启
SET GLOBAL slow_query_log = ON;
-- 慢查询时间
SHOW VARIABLES LIKE '%long_query_time%';
-- 设置慢查询时间 1 秒
SET GLOBAL long_query_time = 1;
```

### 6.索引、查询优化

物理查询优化（索引、表连接）、逻辑查询优化（换一种写法，子查询-》内连接）

#### 1.索引失效

1.计算、函数、类型转换（自动或手动）导致

LEFT(student.name,3)="abc" 此时 name 的索引失效

常见：字段是 varchar 类型，但是查询使用的是 数值，需要自动转换，无法使用索引

```mysql
EXPLAIN
SELECT * FROM device WHERE iccid = 8986112225504359453
```

![image-20230808205543233](pic\image-20230808205543233.png)

2.范围场景下，联合索引失效

建议：联合索引时，等值、常用字段放在最左边  范围查询（日期、金额）的字段放在最右边

3.!= 或者 <> 失效

不等于无法使用，因为不知道那个不等于，需要扫描全表

4.is null 可以使用索引，is not null 不能使用索引

类似情况 3 ，一般加上非 null 条件。数值 0 字符 ''

5.like % 开头失效

6.or 左右有非索引列 失效

一个没有，一个有，没有的需要全表扫描，并集不如都全表

**练习**

假设：index(a,b,c)

![image-20230808210647175](pic\image-20230808210647175.png)

#### 2.关联查询优化

1.左(右)外连接

被驱动表(右表)添加索引。注意类型要一致，否则会有隐式转换。

2.内连接 inner join

最好都加索引。如果只有一个索引，优化器会自动优化有索引的表为被驱动表。

都有索引的话，小表驱动大表，左小右大

**关于join连接**

**开销统计**

![image-20230809095848781](pic\image-20230809095848781.png)

**参数设置：**

- block_nested_loop

通过 `SHOW VARIABLES LIKE '%optimizer_switch%'` 查询

```shell
index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on
```

- join_buffer_size

通过 `SHOW VARIABLES LIKE '%join_buffer_size%'` 查询，默认 256KB 32位系统最大4G

![image-20230809100431998](pic\image-20230809100431998.png)

**小表驱动大表**

实质上是小的结果集驱动大的结果集（表行数*每行大小）。减少内层循环数据量。

mysql 8.0.20 后将废弃 BNLJ ，加入 **hash join**，默认都是 hash join

**hash join**

![image-20230809101318113](pic\image-20230809101318113.png)

#### 3.子查询优化

子查询建立临时表，不存在索引，且较大时，影响性能

可以使用 join 链接代替

> 尽量不要使用 not in 或者 not exists，用 left join xxx on xx where xx is null 替代

#### 4.排序优化

排序的字段加索引，因为本身就是有序的，避免 filesort 排序

mysql 支持两种 filesort（差） index 排序

添加 limit 可以使用索引，因为条数少，走索引剩时间

![image-20230809212017853](pic\image-20230809212017853.png)

#### 5.group by 优化

类似 order by ，无法使用时，增大 max_length_for_sort_data sort_buffer_size 参数

#### 6.分页查询优化

查询大纪录的最后几个数据，如：`select * from table limit 2000000,10;`

1.如果主键自增的表，可以使用 where id > 2000000 查询那个位置的数据

2.非自增时，先用索引列进行排序，然后再去查找数据

`select * from student t,(select id from student order by id limit 200000,10) a where t.id = a.id`

**覆盖索引**：一个索引包含了满足查询结果的数据（不用回表，索引列+主键=select查询的数据）

`SELECT device_id FROM device_push_record WHERE device_id != 'HH_68079417_20'`

正常来说，!= 不会使用索引，但是由于 只查 device_id ，不用回表，走索引划算

#### 7.索引条件下推

`select * from student where key > z and key like '%a'`

这条查询先查询 > z，然后先不回表，进行下一次 like 判断，全判断完在去回表。通常用在联合索引

5.6新特性，默认开启，关闭如下

`SET optimizer_switch = 'index_condition_pushdown=off'`

#### 8. exists in 使用

![image-20230810193051727](pic\image-20230810193051727.png)

A 小用 in B 小用 exists

#### 9.count(*) count(1)

MyISAM 中 复杂度 O(1) ，因为 meta 信息存储了 row_count 

InnoDB 中 扫描全表，复杂度 O(n)

如果是字段的话 count(字段) 尽量用 二级索引，因为主键聚簇索引数据多

### 自增id问题

1. 可靠性不高，自增 id 回溯问题，8.0 修复
2. 安全性不高，容易猜测数量、容易爬取
3. 性能查，id在数据库服务端生成
4. 交互多，需要额外执行 last_insert_id() 才可以知道自增的值是多少
5. 局部唯一性，不是全局唯一，分布式是噩梦

### 事务

#### 1.ACID 原子性 一致性 隔离性 持久性（redo undo）

![image-20230810213017234](pic\image-20230810213017234.png)

#### 2.数据并发问题

1.脏写，A提交的数据被B给回滚了

![image-20230811170757811](pic\image-20230811170757811.png)

2.脏读，A读取B数据没提交的数据

![image-20230811170944053](pic\image-20230811170944053.png)

3.不可重复读，多次读取 值不同

![image-20230811171107023](pic\image-20230811171107023.png)

4.幻读， 多次读取，数据增多

![image-20230811171248154](.\pic\image-20230811171248154.png)

总之，在一个事务中进行多次查询（单次查询就是脏读），另一个事务进行增删改，修改导致的不一致结果为不可重复读，增删导致的不一致结果为幻读。

#### 3.隔离级别：

查看：`SHOW VARIABLES LIKE 'transaction_isolation';`

设置：`SET TRANSACTION_ISOLATION = ''`

> READ-UNCOMMITTED 读未提交
> READ-COMMITTED       读已提交
> REPEATABLE-READ	   可重复读
> SERIALIZABLE				串行化

#### 4.日志

都是存储引擎生成的日志，

**redo**：记录的是“物理级别”上的页面修改，比如：页号xxx、偏移量yyy、写入了zzz数据，保证数据可靠性

**undo**：记录的是“逻辑操作”日志，insert执行会记录delete，用于事务回滚、一致性非锁定读（mvcc）

所有的数据都要先从磁盘加载到缓冲池（buffer pool）中，然后进行增删改查，最后以一定的频率刷入磁盘（checkpoint）

InnoDB事务采用了wal技术（write-ahead logging），这种思想是先写日志，在写磁盘，只有当日志写入成功才算事务提交成功。这里的日志就是 redo log，当宕机未刷盘时，可通过 redo log 恢复

**redo好处、特点**

好处：1.降低刷盘频率 2.日志占用空间非常小（表空间id、页号、偏移量、更新值）

特点：1.顺序写入磁盘 2.事务执行过程中，redo 不断记录