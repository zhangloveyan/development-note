# 微服务

其他：

- resttemplate使用
- pom详解 dependencyManagement
- idea 启动 设置各种参数 port env参数
- jmeter 使用
- 日志 logback

# 注册中心

注册中心、配置中心、服务管理 平台

注册中心演变：

跨进程通信 RPC ，使用 http 请求进行数据访问获取。然后各服务把自己的地址记到一个表中，每次去查询表，获取地址。

如果完成上面的功能，需要什么？

1. 一个服务用来管理和维护这些注册表
2. 客户端通过请求将自身的地址等信息告诉服务
3. 客户端通过请求将注册表拉取到本地，每隔一段时间都需要重复更新
4. 客户端发送心跳，证明自己还在，同时服务端检测客户端是否健康，否则停掉

综合如下图：

![image-20230829103208613](pic/image-20230829103208613.png)

nacos如下：

![nacos](pic/nacos.png)

CAP C 一致性 A 可用性 P 分区容错

# 负载均衡

负载均衡 硬件 F5、软件 nginx、客户端自己做的负载均衡

**ribbon**

属于 netflix ，目前已经不在维护，可使用 loadbalancer，可自己实现，重写 choose 方法，搭建灰度发布功能

loadbalancer 支持 webclient（webflux），ribbon 不支持

常见负载均衡算法

- 随机：随机选择，使用很少
- 轮训：默认算法，定义变量，每次请求变量+1，然后和服务数取模，模几用几
- 加权：把所有权重排列成一个数据，然后请求随机落在某一个区间，如：20% 80%( 0-20, 20-99)
- 地址hash：根据 ip 进行 hash 进行选择，想 hashmap 一样
- 最小链接数：根据积压数等参数，将请求分配在压力最小的服务器上

# 跨进程通讯 RPC

不在一个服务上，如何请求数据，通过 http 请求调用数据。

http 选择：httpclient、okhttp、httpurlconnection、resttemplate、webclient（webflux）

**openfeign** 原理

本质还是 http 通讯



请求过程

![openfeign](pic/openfeign.png)





# 流量控制

应对洪峰流量：秒杀、大促、下单、订单回流处理

消息性场景：削峰填谷、冷热启动

付费系统：根据使用流量付费

API Gateway：精准控制 API 流量

任何应用：探测应用中运行的慢程序块，进行限制

## **sentinel** 原理

使用：

1.dashboard 控制台

2.代码写规则

3.注解方式（推荐）

```
添加依赖
<!-- sentinel 流控管理 -->
<dependency>
	<groupId>com.alibaba.cloud</groupId>
	<artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>

<!-- sentinel 看板 -->
<dependency>
	<groupId>com.alibaba.csp</groupId>
	<artifactId>sentinel-transport-simple-http</artifactId>
	<version>1.8.6</version>
</dependency>

<!-- sentinel 规则管理 -->
<dependency>
	<groupId>com.alibaba.csp</groupId>
	<artifactId>sentinel-datasource-nacos</artifactId>
</dependency>
```

```
@GetMapping("/env")
// 添加资源注解 转发方法  同时指定  block 优先级最高
@SentinelResource(value = "env", blockHandler = "envHandler", fallback = "envFallback")
public String env(String str) {
	return str + "当前环境：" + env;
}

// 方法必须 public 且返回数据、参数与原方法都要保持一致
public String envHandler(String str, BlockException ex) {
	return ex.getMessage() + "阻塞后返回的数据";
}

// 方法必须 public 且返回数据、参数与原方法都要保持一致
public String envFallback(String str, Throwable ex) {
	return ex.getMessage() + "异常后返回的数据";
}
```

统一异常处理 blockexceptionhandler

流控规则

QPS 信号量

# 分布式事务

seta

# 网关

gateway

# 链路追踪

skywalking

# 权限认证 spring security

## 基础使用

### 1. UsernamePasswordAuthenticationToken

用来封装用户的信息类，将用户的用户名、密码、权限等信息封装到该类中。

**构造方法**

![image-20231215100751243](pic/image-20231215100751243.png)

principal 是认证的主体信息，通常为用户名或者用户对象

credentials 是认证的凭证信息，通常为密码或者其他类似信息

authorities 认证请求设置授权信息、权限列表等

**继承关系**

![image-20231215101817585](pic/image-20231215101817585.png)

### 2. SecurityContextHolder

将通过验证后的用户对象设置到 SecurityContextHolder 中，系统就可以在任何地方通过 holder 取出该用户的认证信息。SecurityContext 值与当前执行线程相关联，里面维护了一个 ThreadLocalSecurityContextHolderStrategy 类，具体使用的还是 ThreadLocal 存储信息。

设置代码

![image-20231215105839813](pic/image-20231215105839813.png)

### 3. AuthenticationManager（interface）

![image-20231215101136966](pic/image-20231215101136966.png)

认证处理接口，将用户信息（UsernamePasswordAuthenticationToken）传入后进行验证，最终调用 UserServiceImpl 接口的 loadUserByUsername 方法，通过后会返回 Authentication 对象，也就是需要存储在 SecurityContextHolder 的对象。

调用过程如图：

其中 TokenFilter（extends OncePerRequestFilter）是自定义的拦截请求类。

需要自定义类来实现 UserDetailsService 的 loadUserByUsername 方法，进行验证。

![image-20231215104821947](pic/image-20231215104821947.png)

### 4. 简单的实现

#### 1. 拦截类

```java
package com.wxkj.iot.platform.security;

import com.wxkj.iot.platform.utils.RedisUtil;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.annotation.Resource;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
@Slf4j
public class TokenFilter extends OncePerRequestFilter {
    @Resource
    AuthenticationManager authenticationManager;

    private final static String AUTHORIZATION_HEADER_NAME = "Authorization";

    @Override
    protected void doFilterInternal(@NotNull HttpServletRequest request, @NotNull HttpServletResponse response,
                                    @NotNull FilterChain filterChain) throws ServletException, IOException {
        // 获取 token
        String token = request.getHeader(AUTHORIZATION_HEADER_NAME);

        // 通过 token 获取用户信息
        User user = (User) RedisUtil.get(token);

        // 封装用户信息
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword());

        // 调用方法进行认证
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);

        // 设置到上下文
        SecurityContextHolder.getContext().setAuthentication(authenticate);
    }
}
```

#### 2. 用户信息处理类

```java
package com.wxkj.iot.platform.system;

import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;

@Slf4j
@Service
public class UserServiceImpl implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        System.out.println("执行方法");
        ArrayList<GrantedAuthority> authorities = new ArrayList<>();
        // 通常需要查询数据库进行验证
        User user = new User("user", "root", authorities);
        return user;
    }
}
```

#### 3. Security 配置类

```java
package com.wxkj.iot.platform.security.config;

import com.wxkj.iot.platform.security.TokenFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import javax.annotation.Resource;

/**
 * @author zln
 * @description security  2.7 以上
 * @date 2022/11/24 15:38
 */
@EnableWebSecurity
@Configuration
public class WebSecurityConfig {

    @Resource
    UserDetailsService userDetailsService;
    @Resource
    @Lazy
    TokenFilter tokenFilter;
    
    /**
     * 不需要拦截的地址
     */
    public static final String[] excludeUrls = {
//            "/**",
            // knife4j 接口文档
            "/webjars/**",
            "/doc.html",
            "/v3/api-docs/**",
            "/favicon.ico",
            "/csrf",
            // druid
            "/druid/**"
    };

    /**
     * 解决无法注入问题
     * 密码明文加密方式配置
     *
     * @return
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 解决无法注入问题
     * 认证管理器
     *
     * @param authConfig
     * @return
     * @throws Exception
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {

        httpSecurity
                // 放行的接口
                .authorizeRequests().antMatchers(excludeUrls).permitAll()
                .and()
                // 其余验证
                .authorizeRequests().anyRequest().authenticated()
                .and()
                // 使用自定义的校验
                .userDetailsService(userDetailsService)
                // 在认证前 自定义拦截处理 将用户信息设置到 SecurityContextHolder 中
                .addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class)
                //其他配置
                .csrf().disable();

        return httpSecurity.build();
    }
}

```

## 权限校验

### 1.路径校验

WebSecurityConfig 配置类

```java
@EnableWebSecurity
@Configuration
// 开启校验
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig {
httpSecurity
    // 根据web路径校验
	.authorizeRequests().antMatchers("url1/**").hasRole("role1").and()
	.authorizeRequests().antMatchers("url2/**").hasAnyRole("role1","role2").and()
	.authorizeRequests().antMatchers("url3/**").hasAnyAuthority("system:add","system:delete").and()
}
```

权限集合在 UserDetails 实现类中的 Collection<? extends GrantedAuthority> getAuthorities(); 方法 需要自己实现

一般在查询用户信息时，设置进去，框架后期根据配置校验

### 2.注解校验

同样需要开启校验

1. **@PreAuthorize**：方法执行前检查
2. **@PostAuthorize**：方法执行后检查，失败抛异常
3. **@PostFilter**：允许方法调用，但是按照表达式过滤方法结果

```java
@PreAuthorize("hasRole('ADMIN')")
public void addUser(User user){
    //如果具有ROLE_ADMIN 权限 则访问该方法
    ....
}

@PostAuthorize：允许方法调用，但是，如果表达式结果为false抛出异常
//returnObject可以获取返回对象user，判断user属性username是否和访问该方法的用户对象的用户名一样。不一样则抛出异常。
@PostAuthorize("returnObject.user.username==principal.username")
public User getUser(int userId){
   //允许进入
...
    return user;
}

//将结果过滤，即选出性别为男的用户
@PostFilter("returnObject.user.sex=='男' ")
public List<User> getUserList(){
    //允许进入
    ...
    return user;
}
```

principal 可获取前登录用户信息

### 3.自定义校验

自定义校验使用 **@hasPermission** 校验

```java
@PreAuthorize("hasPermission('tagert','read')")
@GetMapping("/test")
public String test() {
    return "test";
}
```

需要自定义类实现接口，实现自己的校验逻辑

```java
@Component
@Slf4j
public class MyPermissionEvaluator implements PermissionEvaluator {
    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        // 自己的校验逻辑
        // true 可以访问 
        // false 不可访问 并且抛出 accessdefine 异常
        return true;
    }

    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
        return true;
    }
}
```

## 问题

### 1. 反序列化时，没有无参构造方法，反序列化异常

参考：https://zhuanlan.zhihu.com/p/497657071

原因：反序列化需要用到无参方法创建对象，然后在调用 set 方法赋值，如果没有无参方法，会报异常。

处理：使用 @JsonCreator @JsonProperty 处理

@JsonCreator 注解的作用就是指定反序列化时用的无参构造函数。构造方法的参数前面需要加上 @JsonProperty, 否则会报错！

```java
@Getter
@Setter
public class UserDto extends User implements Serializable {

    @Serial
    private static final long serialVersionUID = -5861077067941331352L;

    private String id;

    @JsonCreator
    public UserDto(@JsonProperty("username") String username,
                   @JsonProperty("password") String password,
                   @JsonProperty("authorities") Collection<? extends GrantedAuthority> authorities) {
        super(username, password, authorities);
    }
}
```

### 2. 在 1 的情况下，password = null 反序列化失败

security 处理的过程中，会将 password 置为 null，写入 redis 时，password 字段会忽略。

正常情况，字段忽略不影响反序列化，但是由于 password 是构造方法中的参数，不能为 null 或 无。

如果是继承 user 的类，password 没有 set 方法，只有 get ，无法重新赋值。

所以还会出现异常。

处理：

第一种方法：

1. redis 存储时，bean 转成 json string 存储。
2. 解析时，不直接通过 T.class 反序列化成实体类。
3. 使用 readTree 方法解析成节点，只解析需要的字段。`JsonNode jsonNode = mapper.readTree(json);`

第二种方法：

不继承 user 类，实现 userdetial 接口。要注意实现的权限等类型，要改成 true，涉及锁定、权限等。

```java
package com.wxkj.iot.platform.system.bean.response;

import lombok.Getter;
import lombok.Setter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serial;
import java.io.Serializable;
import java.util.Collection;
import java.util.List;

@Getter
@Setter
public class UserDto implements UserDetails, Serializable {

    @Serial
    private static final long serialVersionUID = -5861077067941331352L;

    private String id;
    private String username;
    private String password;
    private List<? extends GrantedAuthority> authorities;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return !false;
    }

    @Override
    public boolean isAccountNonLocked() {
        return !false;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return !false;
    }

    @Override
    public boolean isEnabled() {
        return !false;
    }
}

```

### 

## jwt 注意事项

生成的 token 结构组成：

JWT的结构：{header}.{payload}.{signature}, 其签名计算过程：HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), signature)

在线地址：https://www.toolhelper.cn/EncodeDecode/Base64EncodeDecode

![image-20240109120243426](pic/image-20240109120243426.png)

注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。

签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。

iss(Issuser)：代表这个JWT的签发主体；
sub(Subject)：代表这个JWT的主体，即它的所有人；
aud(Audience)：代表这个JWT的接收对象；
exp(Expiration time)：是一个时间戳，代表这个JWT的过期时间；
nbf(Not Before)：是一个时间戳，代表这个JWT生效的开始时间，意味着在这个时间之前验证JWT是会失败的；
iat(Issued at)：是一个时间戳，代表这个JWT的签发时间；
jti(JWT ID)：是JWT的唯一标识。
