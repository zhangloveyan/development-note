# 物联网技术

---
tags: [物联网, IoT, 时序数据库, TDengine, 数据采集, 设备管理]
created: 2026-02-21
updated: 2026-02-21
status: 已完成
importance: ⭐⭐⭐⭐⭐
---

## 🎯 核心要点
> 物联网系统架构和时序数据库的实战应用

- **时序数据库**：专为IoT场景优化的数据存储方案
- **TDengine实战**：高性能时序数据库的部署和使用
- **数据采集**：Telegraf等工具的集成应用
- **存储优化**：LSM树结构和性能调优策略

## 📊 时序数据库基础

### 核心概念解析

#### 1. 时序数据特征
**定义**：随时间不断产生的一系列数据，每个数据都有时间戳

**特点**：
- **写多读少**：数据持续写入，查询相对较少
- **按时间排序**：数据按时间顺序写入
- **时效性强**：通常只关注最近的数据
- **数据量大**：设备数量多，采集频率高

**典型应用场景**：
```
服务器监控：每隔几秒采集CPU、内存、磁盘使用率
设备传感器：温度、湿度、压力等环境数据
工业设备：机器运行状态、生产数据
智能家居：用电量、水流量、门窗状态
```

#### 2. 时序点结构
以 InfluxDB 为例的数据结构：

```
measurement,tag_set field_set timestamp
```

**组成部分**：
- **Measurement**（测量名称）：类似数据库的表
- **Tag Set**（标签集）：类似索引，用于分类标记
- **Field Set**（字段集）：实际存储的数据值
- **Timestamp**（时间戳）：数据产生的时间

**实际示例**：
```
parking,name=1 num=50,remain=30 1698661720821
# 解释：停车场1号，总共50个停车位，剩余30个，时间戳
```

### 与关系型数据库的区别

#### 存储结构对比

| 特性 | 关系型数据库 | 时序数据库 |
|------|-------------|------------|
| 存储结构 | B+ 树 | LSM 树变种 |
| 写入性能 | 随机IO，可能叶分裂 | 顺序写入，性能更高 |
| 查询特点 | 复杂关联查询 | 时间范围查询 |
| 数据特点 | 频繁更新删除 | 几乎不更新删除 |
| 扩展性 | 垂直扩展为主 | 水平扩展友好 |

#### 为什么不用 B+ 树？

**B+ 树的问题**：
1. **写入性能**：可能造成叶分裂，产生随机IO
2. **扩展性**：单表数据量大时，树层级变高，查找IO增加
3. **场景不匹配**：时序数据写多读少、很少更新删除的特点与B+树优势不符

## 🏗️ LSM 树存储引擎

### LSM 树核心思想

**LSM-Tree**（Log-Structured Merge-Tree）：日志结构合并树

**核心特性组合**：
- 磁盘顺序写
- 多个树状数据结构
- 冷热数据分级
- 定期归并
- 非原地更新

### LSM 树结构定义

#### 6条核心定义

1. **森林结构**：横跨内存和磁盘的多颗"子树"森林
2. **分层设计**：Level 0（内存）+ Level 1-n（磁盘）
3. **内存结构**：Level 0 使用排序树（红黑树/AVL/跳表）
4. **磁盘结构**：Level 1-n 是排序后顺序写入的文件
5. **阈值合并**：每层达到阈值后合并到下一层
6. **追加写入**：磁盘数据只允许追加，不做原地更新

#### 工作流程

```
写入流程：
数据 → Level 0（内存排序树）→ 达到阈值 →
顺序写入 Level 1 → 达到阈值 → 合并到 Level 2 → ...

查询流程：
Level 0 → Level 1 → Level 2 → ... → 合并结果返回
```

**优势**：
- 顺序写入，提升写入速度
- 牺牲部分查询速度，换取写入性能
- 适合写多读少的时序数据场景

## 🚀 TDengine 实战应用

### TDengine 简介

**定位**：专为物联网、工业互联网场景设计的大数据平台

**核心优势**：
- 高性能时序数据库
- 集群开源、云原生
- 极简部署和使用
- TB/PB级数据处理能力

### 数据模型设计

#### 时序数据特点
```
设备ID + 时间戳 + 多个测量值
例：温度传感器001 + 2024-01-01 10:00:00 + 温度25.5°C + 湿度60%
```

#### 表结构策略

**少表高频模式**（推荐）：
- 单表存储多个设备的同类数据
- 设备ID作为标签区分
- 适合采集频率高的场景

**多表低频模式**：
- 每个设备一张表
- 适合采集频率低、设备数量多的场景

### Docker 部署实战

#### 基础部署
```bash
# 拉取最新镜像
docker pull tdengine/tdengine:latest

# 启动容器
docker run -d \
  -p 6030:6030 \
  -p 6041:6041 \
  -p 6043-6049:6043-6049 \
  -p 6043-6049:6043-6049/udp \
  tdengine/tdengine
```

**端口说明**：
- `6030`：TDengine 服务端口（TCP）
- `6041`：taosAdapter REST 服务端口
- `6043-6049`：第三方应用接入端口

#### 数据持久化部署
```bash
docker run -d \
  -v ~/data/taos/dnode/data:/var/lib/taos \
  -v ~/data/taos/dnode/log:/var/log/taos \
  -p 6030:6030 \
  -p 6041:6041 \
  -p 6043-6049:6043-6049 \
  -p 6043-6049:6043-6049/udp \
  tdengine/tdengine
```

**目录说明**：
- `/var/lib/taos`：数据文件目录
- `/var/log/taos`：日志文件目录

### Java 客户端集成

#### Maven 依赖
```xml
<dependency>
    <groupId>com.taosdata.jdbc</groupId>
    <artifactId>taos-jdbcdriver</artifactId>
    <version>3.2.7</version>
</dependency>
```

#### REST 连接方式
```java
public class TDengineConnection {
    private static final String JDBC_URL =
        "jdbc:TAOS-RS://127.0.0.1:6041?user=root&password=taosdata";

    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(JDBC_URL);
    }
}
```

#### 数据写入示例
```java
public class TDengineWriter {
    private static String[] lines = {
        // 微秒级时间戳
        "meters,location=California.LosAngeles,groupid=2 current=11.8,voltage=221,phase=0.28 1648432611249000",
        "meters,location=California.LosAngeles,groupid=2 current=13.4,voltage=223,phase=0.29 1648432611249500",
        "meters,location=California.LosAngeles,groupid=3 current=10.8,voltage=223,phase=0.29 1648432611249300",
    };

    public static void writeData() throws SQLException {
        try (Connection conn = getConnection()) {
            // 创建数据库（微秒精度）
            createDatabase(conn);

            // 无模式写入
            SchemalessWriter writer = new SchemalessWriter(conn);
            writer.write(lines,
                SchemalessProtocolType.LINE,
                SchemalessTimestampType.MICRO_SECONDS);
        }
    }

    private static void createDatabase(Connection conn) throws SQLException {
        try (Statement stmt = conn.createStatement()) {
            stmt.execute("CREATE DATABASE IF NOT EXISTS test PRECISION 'us'");
            stmt.execute("USE test");
        }
    }
}
```

### IDEA 数据库连接配置

#### 连接配置步骤

1. **下载 JDBC 驱动**
```bash
git clone https://github.com/taosdata/taos-connector-jdbc.git
cd taos-connector-jdbc
mvn clean install -Dmaven.test.skip=true
```

2. **IDEA 数据库配置**
- 数据库类型：选择 Generic
- 驱动：添加编译生成的 jar 文件
- URL：`jdbc:TAOS-RS://127.0.0.1:6041/test`
- 用户名：root
- 密码：taosdata

3. **测试连接**
- 点击 Test Connection 验证
- 成功后可在 Database 面板查看数据

## 📈 数据采集与监控

### Telegraf 集成

#### 安装配置
```bash
# 下载 Telegraf
wget https://dl.influxdata.com/telegraf/releases/telegraf-1.23.4_linux_amd64.tar.gz

# 解压到目标路径
tar -zxvf telegraf-1.23.4_linux_amd64.tar.gz -C /root/influx

# 生成配置文件
cd /root/influx/telegraf-1.23.4/usr/bin
./telegraf --sample-config --input-filter cpu:mem --output-filter http > telegraf.conf
```

#### TDengine 输出配置
```toml
[[outputs.http]]
  ## URL 配置
  url = "http://127.0.0.1:6041/influxdb/v1/write?db=system_demo"

  ## 认证配置
  username = "root"
  password = "taosdata"

  ## 数据格式
  data_format = "influx"

  ## HTTP 配置
  timeout = "5s"
  method = "POST"
```

#### 系统监控配置
```toml
# CPU 监控
[[inputs.cpu]]
  percpu = true
  totalcpu = true
  collect_cpu_time = false
  report_active = false

# 内存监控
[[inputs.mem]]

# 磁盘监控
[[inputs.disk]]
  ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]

# 网络监控
[[inputs.net]]
```

### 启动和监控
```bash
# 启动 Telegraf
./telegraf --config telegraf.conf

# 后台运行
nohup ./telegraf --config telegraf.conf > telegraf.log 2>&1 &

# 查看日志
tail -f telegraf.log
```

## 🔍 性能优化实践

### 数据库优化

#### 1. 数据库设计优化
```sql
-- 创建超级表
CREATE STABLE meters (ts timestamp, current float, voltage int, phase float)
TAGS (location binary(64), groupId int);

-- 创建子表
CREATE TABLE d1001 USING meters TAGS ("California.SanFrancisco", 2);
CREATE TABLE d1002 USING meters TAGS ("California.LosAngeles", 2);
```

#### 2. 查询优化
```sql
-- 时间范围查询（推荐）
SELECT * FROM meters WHERE ts >= '2024-01-01 00:00:00' AND ts < '2024-01-02 00:00:00';

-- 标签过滤查询
SELECT * FROM meters WHERE location = 'California.LosAngeles' AND groupId = 2;

-- 聚合查询
SELECT AVG(current), MAX(voltage) FROM meters
WHERE ts >= now - 1h GROUP BY tbname;
```

#### 3. 写入优化
- **批量写入**：使用批量插入提高写入效率
- **预分配**：合理设置 vgroups 数量
- **压缩配置**：启用数据压缩节省存储空间

### 监控和告警

#### 关键指标监控
```sql
-- 数据写入速率
SELECT COUNT(*) FROM meters WHERE ts >= now - 1m;

-- 存储空间使用
SHOW DATABASES;

-- 查询性能
SELECT LAST(*) FROM meters;
```

#### 告警配置
- 数据写入异常告警
- 存储空间不足告警
- 查询响应时间告警
- 系统资源使用告警

## 🔗 相关文档
- **数据库技术**：[[04-mysql.md]] [[06-mq.md#Redis]]
- **容器部署**：[[08-docker.md]] [[07-工具环境/部署运维实践.md]]
- **项目实战**：[[06-项目实战/项目问题总结.md]]

## 🏷️ 标签
#物联网 #IoT #时序数据库 #TDengine #数据采集 #LSM树 #性能优化