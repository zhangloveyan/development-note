# è®¡ç®—æœºç»„æˆåŸç†

---
tags: [è®¡ç®—æœºç»„æˆåŸç†, è®¡ç®—æœºåŸºç¡€, CPU, å†…å­˜, å­˜å‚¨ç³»ç»Ÿ]
created: 2026-02-21
updated: 2026-02-21
status: å·²æŒæ¡
importance: â­â­â­â­
---

## ğŸ¯ æ ¸å¿ƒè¦ç‚¹
> è®¡ç®—æœºç¡¬ä»¶ç³»ç»Ÿçš„ç»„æˆå’Œå·¥ä½œåŸç†

- **å†¯Â·è¯ºä¾æ›¼æ¶æ„**ï¼šå­˜å‚¨ç¨‹åºè®¡ç®—æœºçš„åŸºæœ¬ç»“æ„
- **CPUå·¥ä½œåŸç†**ï¼šæŒ‡ä»¤æ‰§è¡Œå‘¨æœŸå’Œæµæ°´çº¿æŠ€æœ¯
- **å­˜å‚¨ç³»ç»Ÿ**ï¼šå­˜å‚¨å±‚æ¬¡ç»“æ„å’Œç¼“å­˜æœºåˆ¶
- **I/Oç³»ç»Ÿ**ï¼šè¾“å…¥è¾“å‡ºè®¾å¤‡å’Œæ¥å£æŠ€æœ¯

## ğŸ’¡ åŸç†è¯¦è§£

### 1. è®¡ç®—æœºåŸºæœ¬ç»„æˆ

#### å†¯Â·è¯ºä¾æ›¼æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    è¾“å…¥     â”‚    â”‚    è¾“å‡º     â”‚
â”‚   è®¾å¤‡      â”‚    â”‚   è®¾å¤‡      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                  â”‚
       â–¼                  â–²
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ä¸­å¤®å¤„ç†å™¨             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   è¿ç®—å™¨    â”‚ â”‚   æ§åˆ¶å™¨    â”‚ â”‚
â”‚  â”‚   (ALU)     â”‚ â”‚   (CU)      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å­˜å‚¨å™¨               â”‚
â”‚     (å†…å­˜ + å¤–å­˜)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### äº”å¤§åŸºæœ¬ç»„ä»¶
1. **è¿ç®—å™¨ï¼ˆALUï¼‰**ï¼šæ‰§è¡Œç®—æœ¯å’Œé€»è¾‘è¿ç®—
2. **æ§åˆ¶å™¨ï¼ˆCUï¼‰**ï¼šæ§åˆ¶ç¨‹åºæ‰§è¡Œæµç¨‹
3. **å­˜å‚¨å™¨**ï¼šå­˜å‚¨ç¨‹åºå’Œæ•°æ®
4. **è¾“å…¥è®¾å¤‡**ï¼šå‘è®¡ç®—æœºè¾“å…¥ä¿¡æ¯
5. **è¾“å‡ºè®¾å¤‡**ï¼šè¾“å‡ºè®¡ç®—ç»“æœ

### 2. CPUå·¥ä½œåŸç†

#### æŒ‡ä»¤æ‰§è¡Œå‘¨æœŸ
```
å–æŒ‡ä»¤ â†’ è¯‘ç  â†’ æ‰§è¡Œ â†’ å†™å›
  â†‘                    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### è¯¦ç»†æ‰§è¡Œè¿‡ç¨‹
1. **å–æŒ‡ï¼ˆFetchï¼‰**ï¼šä»å†…å­˜ä¸­å–å‡ºæŒ‡ä»¤
2. **è¯‘ç ï¼ˆDecodeï¼‰**ï¼šè§£ææŒ‡ä»¤æ“ä½œå’Œæ“ä½œæ•°
3. **æ‰§è¡Œï¼ˆExecuteï¼‰**ï¼šæ‰§è¡Œå…·ä½“æ“ä½œ
4. **å†™å›ï¼ˆWrite Backï¼‰**ï¼šå°†ç»“æœå†™å›å¯„å­˜å™¨æˆ–å†…å­˜

#### æµæ°´çº¿æŠ€æœ¯
```
æ—¶é’Ÿå‘¨æœŸ: 1  2  3  4  5  6  7  8
æŒ‡ä»¤1:   F  D  E  W
æŒ‡ä»¤2:      F  D  E  W
æŒ‡ä»¤3:         F  D  E  W
æŒ‡ä»¤4:            F  D  E  W
```

### 3. å­˜å‚¨ç³»ç»Ÿå±‚æ¬¡ç»“æ„

```
CPUå¯„å­˜å™¨ â†â†’ L1ç¼“å­˜ â†â†’ L2ç¼“å­˜ â†â†’ L3ç¼“å­˜ â†â†’ ä¸»å­˜ â†â†’ å¤–å­˜
   â†‘           â†‘        â†‘        â†‘       â†‘      â†‘
 é€Ÿåº¦å¿«      å®¹é‡å°                           å®¹é‡å¤§
 å®¹é‡å°      æˆæœ¬é«˜                           æˆæœ¬ä½
```

#### å­˜å‚¨å™¨ç‰¹æ€§å¯¹æ¯”

| å­˜å‚¨å™¨ç±»å‹ | è®¿é—®æ—¶é—´ | å®¹é‡ | æˆæœ¬ | æ˜“å¤±æ€§ |
|------------|----------|------|------|--------|
| å¯„å­˜å™¨ | <1ns | KB | æé«˜ | æ˜¯ |
| L1ç¼“å­˜ | 1-2ns | KB | å¾ˆé«˜ | æ˜¯ |
| L2ç¼“å­˜ | 3-10ns | MB | é«˜ | æ˜¯ |
| ä¸»å­˜ | 50-100ns | GB | ä¸­ç­‰ | æ˜¯ |
| SSD | 0.1ms | TB | è¾ƒä½ | å¦ |
| æœºæ¢°ç¡¬ç›˜ | 5-10ms | TB | ä½ | å¦ |

## ğŸ”§ ä»£ç ç¤ºä¾‹

### åŸºç¡€ç”¨æ³•

#### CPUæ€§èƒ½æµ‹è¯•
```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

// æµ‹è¯•CPUæ•´æ•°è¿ç®—æ€§èƒ½
void test_integer_performance() {
    clock_t start, end;
    long long sum = 0;
    const int iterations = 100000000;

    printf("æµ‹è¯•æ•´æ•°è¿ç®—æ€§èƒ½...\n");
    start = clock();

    for (int i = 0; i < iterations; i++) {
        sum += i * i;
    }

    end = clock();
    double cpu_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("æ‰§è¡Œ %d æ¬¡æ•´æ•°è¿ç®—\n", iterations);
    printf("è€—æ—¶: %.2f ç§’\n", cpu_time);
    printf("æ€§èƒ½: %.2f MIPS\n", iterations / cpu_time / 1000000);
    printf("ç»“æœ: %lld\n", sum);
}

// æµ‹è¯•CPUæµ®ç‚¹è¿ç®—æ€§èƒ½
void test_float_performance() {
    clock_t start, end;
    double sum = 0.0;
    const int iterations = 50000000;

    printf("\næµ‹è¯•æµ®ç‚¹è¿ç®—æ€§èƒ½...\n");
    start = clock();

    for (int i = 0; i < iterations; i++) {
        sum += i * 3.14159 / (i + 1);
    }

    end = clock();
    double cpu_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("æ‰§è¡Œ %d æ¬¡æµ®ç‚¹è¿ç®—\n", iterations);
    printf("è€—æ—¶: %.2f ç§’\n", cpu_time);
    printf("æ€§èƒ½: %.2f MFLOPS\n", iterations / cpu_time / 1000000);
    printf("ç»“æœ: %.6f\n", sum);
}

int main() {
    test_integer_performance();
    test_float_performance();
    return 0;
}
```

#### å†…å­˜è®¿é—®æ¨¡å¼æµ‹è¯•
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define ARRAY_SIZE (64 * 1024 * 1024)  // 64MB
#define ITERATIONS 10

// æµ‹è¯•é¡ºåºè®¿é—®æ€§èƒ½
void test_sequential_access() {
    int *array = malloc(ARRAY_SIZE * sizeof(int));
    if (!array) {
        printf("å†…å­˜åˆ†é…å¤±è´¥\n");
        return;
    }

    clock_t start = clock();

    for (int iter = 0; iter < ITERATIONS; iter++) {
        for (int i = 0; i < ARRAY_SIZE; i++) {
            array[i] = i;
        }
    }

    clock_t end = clock();
    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("é¡ºåºè®¿é—®æµ‹è¯•:\n");
    printf("æ•°ç»„å¤§å°: %d MB\n", ARRAY_SIZE * sizeof(int) / (1024 * 1024));
    printf("è€—æ—¶: %.2f ç§’\n", time_taken);
    printf("å¸¦å®½: %.2f MB/s\n",
           (ARRAY_SIZE * sizeof(int) * ITERATIONS) / time_taken / (1024 * 1024));

    free(array);
}

// æµ‹è¯•éšæœºè®¿é—®æ€§èƒ½
void test_random_access() {
    int *array = malloc(ARRAY_SIZE * sizeof(int));
    int *indices = malloc(ARRAY_SIZE * sizeof(int));

    if (!array || !indices) {
        printf("å†…å­˜åˆ†é…å¤±è´¥\n");
        return;
    }

    // ç”Ÿæˆéšæœºç´¢å¼•
    for (int i = 0; i < ARRAY_SIZE; i++) {
        indices[i] = rand() % ARRAY_SIZE;
    }

    clock_t start = clock();

    for (int iter = 0; iter < ITERATIONS; iter++) {
        for (int i = 0; i < ARRAY_SIZE; i++) {
            array[indices[i]] = i;
        }
    }

    clock_t end = clock();
    double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("\néšæœºè®¿é—®æµ‹è¯•:\n");
    printf("æ•°ç»„å¤§å°: %d MB\n", ARRAY_SIZE * sizeof(int) / (1024 * 1024));
    printf("è€—æ—¶: %.2f ç§’\n", time_taken);
    printf("å¸¦å®½: %.2f MB/s\n",
           (ARRAY_SIZE * sizeof(int) * ITERATIONS) / time_taken / (1024 * 1024));

    free(array);
    free(indices);
}

int main() {
    srand(time(NULL));
    test_sequential_access();
    test_random_access();
    return 0;
}
```

### é«˜çº§ç”¨æ³•

#### ç¼“å­˜æ€§èƒ½åˆ†æ
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// æµ‹è¯•ä¸åŒæ­¥é•¿çš„å†…å­˜è®¿é—®ï¼Œè§‚å¯Ÿç¼“å­˜æ•ˆæœ
void test_cache_performance() {
    const int array_size = 64 * 1024 * 1024;  // 64MB
    int *array = malloc(array_size * sizeof(int));

    if (!array) {
        printf("å†…å­˜åˆ†é…å¤±è´¥\n");
        return;
    }

    // åˆå§‹åŒ–æ•°ç»„
    for (int i = 0; i < array_size; i++) {
        array[i] = i;
    }

    printf("ç¼“å­˜æ€§èƒ½æµ‹è¯• (æ•°ç»„å¤§å°: %d MB)\n",
           array_size * sizeof(int) / (1024 * 1024));
    printf("æ­¥é•¿\tè®¿é—®æ—¶é—´(ms)\tå¸¦å®½(MB/s)\n");

    // æµ‹è¯•ä¸åŒæ­¥é•¿
    int steps[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024};
    int num_steps = sizeof(steps) / sizeof(steps[0]);

    for (int s = 0; s < num_steps; s++) {
        int step = steps[s];
        int accesses = array_size / step;

        clock_t start = clock();

        long long sum = 0;
        for (int i = 0; i < accesses; i++) {
            sum += array[i * step];
        }

        clock_t end = clock();
        double time_ms = ((double)(end - start)) / CLOCKS_PER_SEC * 1000;
        double bandwidth = (accesses * sizeof(int)) / (time_ms / 1000) / (1024 * 1024);

        printf("%d\t%.2f\t\t%.2f\n", step, time_ms, bandwidth);
    }

    free(array);
}

// çŸ©é˜µä¹˜æ³•ç¼“å­˜ä¼˜åŒ–ç¤ºä¾‹
void matrix_multiply_naive(int **a, int **b, int **c, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            c[i][j] = 0;
            for (int k = 0; k < n; k++) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
}

void matrix_multiply_optimized(int **a, int **b, int **c, int n) {
    const int block_size = 64;  // ç¼“å­˜å‹å¥½çš„å—å¤§å°

    for (int ii = 0; ii < n; ii += block_size) {
        for (int jj = 0; jj < n; jj += block_size) {
            for (int kk = 0; kk < n; kk += block_size) {
                // å—å†…è®¡ç®—
                for (int i = ii; i < ii + block_size && i < n; i++) {
                    for (int j = jj; j < jj + block_size && j < n; j++) {
                        for (int k = kk; k < kk + block_size && k < n; k++) {
                            c[i][j] += a[i][k] * b[k][j];
                        }
                    }
                }
            }
        }
    }
}

void test_matrix_multiply() {
    const int n = 512;

    // åˆ†é…çŸ©é˜µå†…å­˜
    int **a = malloc(n * sizeof(int*));
    int **b = malloc(n * sizeof(int*));
    int **c1 = malloc(n * sizeof(int*));
    int **c2 = malloc(n * sizeof(int*));

    for (int i = 0; i < n; i++) {
        a[i] = malloc(n * sizeof(int));
        b[i] = malloc(n * sizeof(int));
        c1[i] = malloc(n * sizeof(int));
        c2[i] = malloc(n * sizeof(int));
    }

    // åˆå§‹åŒ–çŸ©é˜µ
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            a[i][j] = rand() % 100;
            b[i][j] = rand() % 100;
            c1[i][j] = 0;
            c2[i][j] = 0;
        }
    }

    printf("\nçŸ©é˜µä¹˜æ³•æ€§èƒ½æµ‹è¯• (%dx%d):\n", n, n);

    // æµ‹è¯•æœ´ç´ ç®—æ³•
    clock_t start = clock();
    matrix_multiply_naive(a, b, c1, n);
    clock_t end = clock();
    double time_naive = ((double)(end - start)) / CLOCKS_PER_SEC;

    // æµ‹è¯•ä¼˜åŒ–ç®—æ³•
    start = clock();
    matrix_multiply_optimized(a, b, c2, n);
    end = clock();
    double time_optimized = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("æœ´ç´ ç®—æ³•è€—æ—¶: %.2f ç§’\n", time_naive);
    printf("ä¼˜åŒ–ç®—æ³•è€—æ—¶: %.2f ç§’\n", time_optimized);
    printf("æ€§èƒ½æå‡: %.2fx\n", time_naive / time_optimized);

    // é‡Šæ”¾å†…å­˜
    for (int i = 0; i < n; i++) {
        free(a[i]);
        free(b[i]);
        free(c1[i]);
        free(c2[i]);
    }
    free(a);
    free(b);
    free(c1);
    free(c2);
}

int main() {
    test_cache_performance();
    test_matrix_multiply();
    return 0;
}
```

#### åˆ†æ”¯é¢„æµ‹æµ‹è¯•
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ARRAY_SIZE 1000000

// æµ‹è¯•åˆ†æ”¯é¢„æµ‹å¯¹æ€§èƒ½çš„å½±å“
void test_branch_prediction() {
    int *array = malloc(ARRAY_SIZE * sizeof(int));
    if (!array) {
        printf("å†…å­˜åˆ†é…å¤±è´¥\n");
        return;
    }

    // ç”Ÿæˆéšæœºæ•°ç»„
    srand(time(NULL));
    for (int i = 0; i < ARRAY_SIZE; i++) {
        array[i] = rand() % 256;
    }

    printf("åˆ†æ”¯é¢„æµ‹æ€§èƒ½æµ‹è¯•:\n");

    // æµ‹è¯•1: æœªæ’åºæ•°ç»„ï¼ˆåˆ†æ”¯é¢„æµ‹å›°éš¾ï¼‰
    clock_t start = clock();
    long long sum1 = 0;
    for (int i = 0; i < ARRAY_SIZE; i++) {
        if (array[i] >= 128) {
            sum1 += array[i];
        }
    }
    clock_t end = clock();
    double time_unsorted = ((double)(end - start)) / CLOCKS_PER_SEC;

    // æ’åºæ•°ç»„
    for (int i = 0; i < ARRAY_SIZE - 1; i++) {
        for (int j = 0; j < ARRAY_SIZE - i - 1; j++) {
            if (array[j] > array[j + 1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }

    // æµ‹è¯•2: å·²æ’åºæ•°ç»„ï¼ˆåˆ†æ”¯é¢„æµ‹å®¹æ˜“ï¼‰
    start = clock();
    long long sum2 = 0;
    for (int i = 0; i < ARRAY_SIZE; i++) {
        if (array[i] >= 128) {
            sum2 += array[i];
        }
    }
    end = clock();
    double time_sorted = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("æœªæ’åºæ•°ç»„è€—æ—¶: %.4f ç§’ (ç»“æœ: %lld)\n", time_unsorted, sum1);
    printf("å·²æ’åºæ•°ç»„è€—æ—¶: %.4f ç§’ (ç»“æœ: %lld)\n", time_sorted, sum2);
    printf("æ€§èƒ½å·®å¼‚: %.2fx\n", time_unsorted / time_sorted);

    free(array);
}

int main() {
    test_branch_prediction();
    return 0;
}
```

## âš¡ æ€§èƒ½ç‰¹ç‚¹

| ç»„ä»¶ | ç‰¹ç‚¹ | æ€§èƒ½æŒ‡æ ‡ |
|------|------|----------|
| CPU | é«˜é€Ÿè¿ç®—å¤„ç† | æ—¶é’Ÿé¢‘ç‡ã€IPC |
| ç¼“å­˜ | é«˜é€Ÿä¸´æ—¶å­˜å‚¨ | å‘½ä¸­ç‡ã€å»¶è¿Ÿ |
| å†…å­˜ | å¤§å®¹é‡å­˜å‚¨ | å¸¦å®½ã€å»¶è¿Ÿ |
| å­˜å‚¨ | æŒä¹…åŒ–å­˜å‚¨ | IOPSã€ååé‡ |

## ğŸ”— çŸ¥è¯†å…³è”

- **å‰ç½®çŸ¥è¯†**ï¼š[[æ•°å­—ç”µè·¯]] [[è®¡ç®—æœºå¯¼è®º]]
- **ç›¸å…³æŠ€æœ¯**ï¼š[[æ“ä½œç³»ç»ŸåŸç†]] [[ç¼–è¯‘åŸç†]]
- **å®æˆ˜åº”ç”¨**ï¼š[[æ€§èƒ½ä¼˜åŒ–]] [[ç³»ç»Ÿè°ƒä¼˜]]
- **æ·±å…¥å­¦ä¹ **ï¼š[[è®¡ç®—æœºä½“ç³»ç»“æ„]] [[å¹¶è¡Œè®¡ç®—]]

## ğŸ·ï¸ æ ‡ç­¾
#è®¡ç®—æœºç»„æˆåŸç† #CPU #å†…å­˜ #å­˜å‚¨ç³»ç»Ÿ #è®¡ç®—æœºåŸºç¡€ #é¢è¯•é‡ç‚¹