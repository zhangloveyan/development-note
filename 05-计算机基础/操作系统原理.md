# 操作系统 - 原理

---
tags: [操作系统, 计算机基础, 进程管理, 内存管理, 文件系统]
created: 2026-02-21
updated: 2026-02-21
status: 已掌握
importance: ⭐⭐⭐⭐⭐
---

## 🎯 核心要点
> 操作系统的基本原理和核心概念

- **系统启动**：从硬件启动到操作系统加载的完整过程
- **进程管理**：进程创建、调度和通信机制
- **内存管理**：虚拟内存、分页和内存分配策略
- **文件系统**：文件存储、目录结构和I/O管理

## 💡 原理详解

### 1. 操作系统概述

操作系统是计算机硬件和应用程序之间的一层软件，是上层应用和硬件沟通的桥梁。

#### 主要功能
- **硬件管理**：CPU、内存、终端、磁盘、文件、网络、电源、多核
- **资源分配**：合理分配系统资源给各个进程
- **进程调度**：管理进程的创建、执行和销毁
- **安全保护**：提供访问控制和权限管理

### 2. 系统启动过程

以x86架构为例的启动流程：

```
开机 → BIOS → 引导扇区 → 操作系统内核 → 用户空间
```

#### 详细启动过程
1. **开机**：CPU处于实模式，寻址0xFFFF0（ROM BIOS映射区）
2. **BIOS检查**：检查RAM、键盘、显示器、软硬磁盘、主板
3. **引导加载**：将磁盘0磁道0扇区（引导扇区）读入内存0x7c00处
4. **系统加载**：按顺序读取boot → setup → system
5. **进程创建**：执行main函数中的fork()创建第一个进程
6. **用户界面**：fork中调用init方法执行shell（Windows桌面）

### 3. 用户态和内核态

#### 概念区分
- **内核态（Kernel Mode）**：可以执行特权指令，访问所有系统资源
- **用户态（User Mode）**：只能执行非特权指令，访问受限的系统资源

#### 切换机制
- **系统调用**：用户程序请求内核服务
- **中断处理**：硬件中断或异常发生
- **特权指令**：int指令是调用内核代码的唯一方式

### 4. 进程管理

#### 进程概念
进程 = 资源 + 指令执行序列

#### 进程状态
```
新建 → 就绪 → 运行 → 阻塞 → 终止
  ↑      ↓      ↓      ↓
  └──────┴──────┴──────┘
```

#### 进程控制块（PCB）
用来记录进程信息的数据结构，包含：
- 进程标识符（PID）
- 进程状态
- CPU寄存器状态
- 内存管理信息
- I/O状态信息

## 🔧 代码示例

### 基础用法

#### 进程创建示例
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid;

    printf("父进程开始，PID: %d\n", getpid());

    // 创建子进程
    pid = fork();

    if (pid == 0) {
        // 子进程代码
        printf("子进程执行，PID: %d, 父进程PID: %d\n",
               getpid(), getppid());

        // 执行新程序
        execl("/bin/ls", "ls", "-l", NULL);

        // 如果execl成功，下面的代码不会执行
        printf("execl执行失败\n");
    } else if (pid > 0) {
        // 父进程代码
        int status;
        printf("父进程等待子进程，子进程PID: %d\n", pid);

        // 等待子进程结束
        wait(&status);
        printf("子进程结束，状态: %d\n", status);
    } else {
        // fork失败
        perror("fork失败");
        return 1;
    }

    return 0;
}
```

#### 进程间通信 - 管道
```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];  // 管道文件描述符
    pid_t pid;
    char buffer[100];

    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe创建失败");
        return 1;
    }

    pid = fork();

    if (pid == 0) {
        // 子进程 - 读取数据
        close(pipefd[1]);  // 关闭写端

        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';
            printf("子进程收到消息: %s\n", buffer);
        }

        close(pipefd[0]);
    } else if (pid > 0) {
        // 父进程 - 发送数据
        close(pipefd[0]);  // 关闭读端

        const char *message = "Hello from parent!";
        write(pipefd[1], message, strlen(message));

        close(pipefd[1]);
        wait(NULL);  // 等待子进程结束
    } else {
        perror("fork失败");
        return 1;
    }

    return 0;
}
```

### 高级用法

#### 共享内存通信
```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>
#include <unistd.h>

#define SHM_SIZE 1024

int main() {
    key_t key = ftok(".", 'a');  // 生成键值
    int shmid;
    char *shm_ptr;
    pid_t pid;

    // 创建共享内存
    shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);
    if (shmid == -1) {
        perror("shmget失败");
        return 1;
    }

    // 连接共享内存
    shm_ptr = (char *)shmat(shmid, NULL, 0);
    if (shm_ptr == (char *)-1) {
        perror("shmat失败");
        return 1;
    }

    pid = fork();

    if (pid == 0) {
        // 子进程 - 读取共享内存
        sleep(1);  // 等待父进程写入
        printf("子进程读取: %s\n", shm_ptr);

        // 分离共享内存
        shmdt(shm_ptr);
    } else if (pid > 0) {
        // 父进程 - 写入共享内存
        strcpy(shm_ptr, "Hello from shared memory!");
        printf("父进程写入完成\n");

        wait(NULL);  // 等待子进程结束

        // 分离并删除共享内存
        shmdt(shm_ptr);
        shmctl(shmid, IPC_RMID, NULL);
    } else {
        perror("fork失败");
        return 1;
    }

    return 0;
}
```

#### 信号处理
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

// 信号处理函数
void signal_handler(int sig) {
    switch (sig) {
        case SIGINT:
            printf("\n收到SIGINT信号 (Ctrl+C)\n");
            break;
        case SIGTERM:
            printf("收到SIGTERM信号\n");
            break;
        case SIGUSR1:
            printf("收到SIGUSR1信号\n");
            break;
        default:
            printf("收到未知信号: %d\n", sig);
    }
}

int main() {
    // 注册信号处理函数
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    signal(SIGUSR1, signal_handler);

    printf("进程PID: %d\n", getpid());
    printf("等待信号... (按Ctrl+C测试)\n");

    // 无限循环等待信号
    while (1) {
        sleep(1);
        printf(".");
        fflush(stdout);
    }

    return 0;
}
```

#### 多线程编程
```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define NUM_THREADS 3

// 线程函数
void *thread_function(void *arg) {
    int thread_id = *(int *)arg;

    printf("线程 %d 开始执行\n", thread_id);

    // 模拟工作
    for (int i = 0; i < 5; i++) {
        printf("线程 %d: 工作中... %d\n", thread_id, i + 1);
        sleep(1);
    }

    printf("线程 %d 执行完成\n", thread_id);
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];

    printf("主线程开始创建子线程\n");

    // 创建线程
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i + 1;
        int result = pthread_create(&threads[i], NULL,
                                   thread_function, &thread_ids[i]);
        if (result != 0) {
            printf("创建线程 %d 失败\n", i + 1);
            return 1;
        }
    }

    // 等待所有线程完成
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
        printf("线程 %d 已结束\n", i + 1);
    }

    printf("所有线程执行完成\n");
    return 0;
}
```

#### 文件系统操作
```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>

// 文件读写示例
void file_operations() {
    int fd;
    char buffer[100];
    ssize_t bytes_written, bytes_read;

    // 创建并写入文件
    fd = open("test.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd == -1) {
        perror("打开文件失败");
        return;
    }

    const char *data = "Hello, Operating System!";
    bytes_written = write(fd, data, strlen(data));
    printf("写入 %zd 字节\n", bytes_written);
    close(fd);

    // 读取文件
    fd = open("test.txt", O_RDONLY);
    if (fd == -1) {
        perror("打开文件失败");
        return;
    }

    bytes_read = read(fd, buffer, sizeof(buffer) - 1);
    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        printf("读取内容: %s\n", buffer);
    }
    close(fd);

    // 获取文件信息
    struct stat file_stat;
    if (stat("test.txt", &file_stat) == 0) {
        printf("文件大小: %ld 字节\n", file_stat.st_size);
        printf("文件权限: %o\n", file_stat.st_mode & 0777);
    }
}

// 目录操作示例
void directory_operations() {
    DIR *dir;
    struct dirent *entry;

    // 打开当前目录
    dir = opendir(".");
    if (dir == NULL) {
        perror("打开目录失败");
        return;
    }

    printf("当前目录内容:\n");
    while ((entry = readdir(dir)) != NULL) {
        printf("  %s\n", entry->d_name);
    }

    closedir(dir);
}

int main() {
    printf("=== 文件操作示例 ===\n");
    file_operations();

    printf("\n=== 目录操作示例 ===\n");
    directory_operations();

    return 0;
}
```

## ⚡ 性能特点

| 特性 | 说明 | 适用场景 |
|------|------|----------|
| 多任务处理 | 同时运行多个程序 | 现代计算环境 |
| 虚拟内存 | 扩展可用内存空间 | 大型应用程序 |
| 文件系统 | 组织和管理数据 | 数据存储和检索 |
| 设备管理 | 统一的硬件接口 | 硬件抽象 |

## 🔗 知识关联

- **前置知识**：[[计算机组成原理]] [[计算机网络]]
- **相关技术**：[[Linux系统编程]] [[进程间通信]]
- **实战应用**：[[系统性能优化]] [[并发编程]]
- **深入学习**：[[内核源码分析]] [[设备驱动开发]]

## 🏷️ 标签
#操作系统 #计算机基础 #进程管理 #内存管理 #文件系统 #面试重点