# æ•°æ®ç»“æ„ä¸ç®—æ³•

---
tags: [æ•°æ®ç»“æ„, ç®—æ³•, ç¼–ç¨‹åŸºç¡€, ç®—æ³•å¤æ‚åº¦, é¢è¯•é‡ç‚¹]
created: 2026-02-21
updated: 2026-02-21
status: å·²æŒæ¡
importance: â­â­â­â­â­
---

## ğŸ¯ æ ¸å¿ƒè¦ç‚¹
> æ•°æ®ç»“æ„ä¸ç®—æ³•çš„æ ¸å¿ƒæ¦‚å¿µå’Œå®ç°

- **æ•°æ®ç»“æ„æœ¬è´¨**ï¼šç°å®æ•°æ®çš„æŠ½è±¡å­˜å‚¨å’Œå…³ç³»è¡¨ç¤º
- **ç®—æ³•æœ¬è´¨**ï¼šä»¥æœ€æœ‰æ•ˆç‡çš„æ–¹å¼ç©·ä¸¾æ‰€æœ‰å¯èƒ½æ€§
- **å¤æ‚åº¦åˆ†æ**ï¼šæ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦çš„è¯„ä¼°
- **ç»å…¸ç®—æ³•**ï¼šæ’åºã€æŸ¥æ‰¾ã€å›¾è®ºç­‰æ ¸å¿ƒç®—æ³•

## ğŸ’¡ åŸç†è¯¦è§£

### 1. åŸºç¡€æ¦‚å¿µ

#### æ•°æ®ç»“æ„æœ¬è´¨
æ•°æ®ç»“æ„æ˜¯ç°å®ä¸–ç•Œçš„æ•°æ®æŠ½è±¡å­˜å‚¨åœ¨ç‰©ç†è®¾å¤‡ä¸Šï¼Œå°†ç°å®æ•°æ®æŠ½è±¡æˆæœ€å°å•å…ƒçš„æ•°æ®ï¼ŒåŒ…æ‹¬ï¼š
- **æ•°æ®æœ¬èº«çš„å€¼**
- **æ•°æ®ä¸æ•°æ®çš„å…³ç³»**

#### ç‰©ç†å­˜å‚¨æ–¹å¼
- **è¿ç»­å­˜å‚¨ï¼ˆæ•°ç»„ï¼‰**ï¼šæ•°æ®åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾
- **ä¸è¿ç»­å­˜å‚¨ï¼ˆé“¾è¡¨ï¼‰**ï¼šæ•°æ®é€šè¿‡æŒ‡é’ˆé“¾æ¥

#### ç®—æ³•æœ¬è´¨
ä»¥æœ€æœ‰æ•ˆç‡çš„æ–¹å¼ç©·ä¸¾æ‰€æœ‰å¯èƒ½æ€§ï¼Œå¯»æ‰¾è®¡ç®—ç»“æœã€‚

### 2. å¤æ‚åº¦åˆ†æ

#### æ—¶é—´å¤æ‚åº¦ T(n)
- **æœ€åæƒ…å†µå¤æ‚åº¦** Tworst(n)
- **å¹³å‡å¤æ‚åº¦** Tavg(n)

#### ç©ºé—´å¤æ‚åº¦ S(n)
ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰€éœ€è¦çš„å­˜å‚¨ç©ºé—´

#### ç®—æ³•å¤æ‚åº¦ç›´è§‚ä½“ç°
```
O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(nÂ³) < O(2â¿) < O(n!)
```

### 3. åŸºæœ¬æ•°æ®ç»“æ„

#### çº¿æ€§ç»“æ„
- **æ•°ç»„**ï¼šéšæœºè®¿é—®ï¼Œæ’å…¥åˆ é™¤æ•ˆç‡ä½
- **é“¾è¡¨**ï¼šé¡ºåºè®¿é—®ï¼Œæ’å…¥åˆ é™¤æ•ˆç‡é«˜
- **æ ˆ**ï¼šåè¿›å…ˆå‡ºï¼ˆLIFOï¼‰
- **é˜Ÿåˆ—**ï¼šå…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰

#### éçº¿æ€§ç»“æ„
- **æ ‘**ï¼šä¸€å¯¹å¤šå…³ç³»çš„é›†åˆ
- **å›¾**ï¼šå¤šå¯¹å¤šå…³ç³»çš„é›†åˆ
- **å“ˆå¸Œè¡¨**ï¼šé”®å€¼å¯¹æ˜ å°„ç»“æ„

## ğŸ”§ ä»£ç ç¤ºä¾‹

### åŸºç¡€ç”¨æ³•

#### æ•°ç»„å’Œé“¾è¡¨å®ç°
```c
#include <stdio.h>
#include <stdlib.h>

// åŠ¨æ€æ•°ç»„å®ç°
typedef struct {
    int *data;
    int size;
    int capacity;
} DynamicArray;

DynamicArray* create_array(int initial_capacity) {
    DynamicArray *arr = malloc(sizeof(DynamicArray));
    arr->data = malloc(initial_capacity * sizeof(int));
    arr->size = 0;
    arr->capacity = initial_capacity;
    return arr;
}

void array_push(DynamicArray *arr, int value) {
    if (arr->size >= arr->capacity) {
        // æ‰©å®¹
        arr->capacity *= 2;
        arr->data = realloc(arr->data, arr->capacity * sizeof(int));
    }
    arr->data[arr->size++] = value;
}

int array_get(DynamicArray *arr, int index) {
    if (index >= 0 && index < arr->size) {
        return arr->data[index];
    }
    return -1; // é”™è¯¯å€¼
}

// é“¾è¡¨å®ç°
typedef struct ListNode {
    int data;
    struct ListNode *next;
} ListNode;

typedef struct {
    ListNode *head;
    int size;
} LinkedList;

LinkedList* create_list() {
    LinkedList *list = malloc(sizeof(LinkedList));
    list->head = NULL;
    list->size = 0;
    return list;
}

void list_push_front(LinkedList *list, int value) {
    ListNode *new_node = malloc(sizeof(ListNode));
    new_node->data = value;
    new_node->next = list->head;
    list->head = new_node;
    list->size++;
}

void list_print(LinkedList *list) {
    ListNode *current = list->head;
    printf("é“¾è¡¨: ");
    while (current) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

int main() {
    // æµ‹è¯•åŠ¨æ€æ•°ç»„
    DynamicArray *arr = create_array(2);
    for (int i = 0; i < 10; i++) {
        array_push(arr, i * i);
    }

    printf("åŠ¨æ€æ•°ç»„: ");
    for (int i = 0; i < arr->size; i++) {
        printf("%d ", array_get(arr, i));
    }
    printf("\n");

    // æµ‹è¯•é“¾è¡¨
    LinkedList *list = create_list();
    for (int i = 0; i < 5; i++) {
        list_push_front(list, i);
    }
    list_print(list);

    return 0;
}
```

#### æ ˆå’Œé˜Ÿåˆ—å®ç°
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// æ ˆå®ç°
typedef struct {
    int *data;
    int top;
    int capacity;
} Stack;

Stack* create_stack(int capacity) {
    Stack *stack = malloc(sizeof(Stack));
    stack->data = malloc(capacity * sizeof(int));
    stack->top = -1;
    stack->capacity = capacity;
    return stack;
}

bool stack_push(Stack *stack, int value) {
    if (stack->top >= stack->capacity - 1) {
        return false; // æ ˆæ»¡
    }
    stack->data[++stack->top] = value;
    return true;
}

bool stack_pop(Stack *stack, int *value) {
    if (stack->top < 0) {
        return false; // æ ˆç©º
    }
    *value = stack->data[stack->top--];
    return true;
}

bool stack_is_empty(Stack *stack) {
    return stack->top < 0;
}

// é˜Ÿåˆ—å®ç°
typedef struct {
    int *data;
    int front;
    int rear;
    int size;
    int capacity;
} Queue;

Queue* create_queue(int capacity) {
    Queue *queue = malloc(sizeof(Queue));
    queue->data = malloc(capacity * sizeof(int));
    queue->front = 0;
    queue->rear = -1;
    queue->size = 0;
    queue->capacity = capacity;
    return queue;
}

bool queue_enqueue(Queue *queue, int value) {
    if (queue->size >= queue->capacity) {
        return false; // é˜Ÿåˆ—æ»¡
    }
    queue->rear = (queue->rear + 1) % queue->capacity;
    queue->data[queue->rear] = value;
    queue->size++;
    return true;
}

bool queue_dequeue(Queue *queue, int *value) {
    if (queue->size <= 0) {
        return false; // é˜Ÿåˆ—ç©º
    }
    *value = queue->data[queue->front];
    queue->front = (queue->front + 1) % queue->capacity;
    queue->size--;
    return true;
}

// ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€è¡¨è¾¾å¼ç¤ºä¾‹
void infix_to_postfix_demo() {
    printf("\nä¸­ç¼€è½¬åç¼€è¡¨è¾¾å¼ç¤ºä¾‹:\n");
    printf("ä¸­ç¼€: 6 + 2 * 3 - 4 / 2\n");
    printf("åç¼€: 6 2 3 * + 4 2 / -\n");

    // åç¼€è¡¨è¾¾å¼è®¡ç®—: 6 2 3 * + 4 2 / -
    Stack *stack = create_stack(10);
    int values[] = {6, 2, 3};
    char ops[] = {'*', '+', 4, 2, '/', '-'};

    // ç®€åŒ–çš„åç¼€è®¡ç®—æ¼”ç¤º
    stack_push(stack, 6);
    stack_push(stack, 2);
    stack_push(stack, 3);

    int b, a;
    stack_pop(stack, &b); // 3
    stack_pop(stack, &a); // 2
    stack_push(stack, a * b); // 6

    stack_pop(stack, &b); // 6
    stack_pop(stack, &a); // 6
    stack_push(stack, a + b); // 12

    stack_push(stack, 4);
    stack_push(stack, 2);

    stack_pop(stack, &b); // 2
    stack_pop(stack, &a); // 4
    stack_push(stack, a / b); // 2

    stack_pop(stack, &b); // 2
    stack_pop(stack, &a); // 12
    int result = a - b; // 10

    printf("è®¡ç®—ç»“æœ: %d\n", result);
}

int main() {
    // æµ‹è¯•æ ˆ
    Stack *stack = create_stack(5);
    printf("æ ˆæ“ä½œæµ‹è¯•:\n");
    for (int i = 1; i <= 5; i++) {
        stack_push(stack, i);
        printf("å…¥æ ˆ: %d\n", i);
    }

    int value;
    while (!stack_is_empty(stack)) {
        stack_pop(stack, &value);
        printf("å‡ºæ ˆ: %d\n", value);
    }

    // æµ‹è¯•é˜Ÿåˆ—
    Queue *queue = create_queue(5);
    printf("\né˜Ÿåˆ—æ“ä½œæµ‹è¯•:\n");
    for (int i = 1; i <= 5; i++) {
        queue_enqueue(queue, i);
        printf("å…¥é˜Ÿ: %d\n", i);
    }

    while (queue->size > 0) {
        queue_dequeue(queue, &value);
        printf("å‡ºé˜Ÿ: %d\n", value);
    }

    // ä¸­ç¼€è½¬åç¼€ç¤ºä¾‹
    infix_to_postfix_demo();

    return 0;
}
```

### é«˜çº§ç”¨æ³•

#### äºŒå‰æ ‘å®ç°å’Œéå†
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

TreeNode* create_node(int data) {
    TreeNode *node = malloc(sizeof(TreeNode));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// å…ˆåºéå†ï¼šæ ¹ -> å·¦å­æ ‘ -> å³å­æ ‘
void preorder_traversal(TreeNode *root) {
    if (root) {
        printf("%d ", root->data);
        preorder_traversal(root->left);
        preorder_traversal(root->right);
    }
}

// ä¸­åºéå†ï¼šå·¦å­æ ‘ -> æ ¹ -> å³å­æ ‘
void inorder_traversal(TreeNode *root) {
    if (root) {
        inorder_traversal(root->left);
        printf("%d ", root->data);
        inorder_traversal(root->right);
    }
}

// ååºéå†ï¼šå·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹
void postorder_traversal(TreeNode *root) {
    if (root) {
        postorder_traversal(root->left);
        postorder_traversal(root->right);
        printf("%d ", root->data);
    }
}

// å±‚åºéå†ï¼ˆä½¿ç”¨é˜Ÿåˆ—ï¼‰
void level_order_traversal(TreeNode *root) {
    if (!root) return;

    TreeNode *queue[1000];
    int front = 0, rear = 0;

    queue[rear++] = root;

    while (front < rear) {
        TreeNode *current = queue[front++];
        printf("%d ", current->data);

        if (current->left) {
            queue[rear++] = current->left;
        }
        if (current->right) {
            queue[rear++] = current->right;
        }
    }
}

// äºŒå‰æœç´¢æ ‘æ’å…¥
TreeNode* bst_insert(TreeNode *root, int data) {
    if (!root) {
        return create_node(data);
    }

    if (data < root->data) {
        root->left = bst_insert(root->left, data);
    } else if (data > root->data) {
        root->right = bst_insert(root->right, data);
    }

    return root;
}

// äºŒå‰æœç´¢æ ‘æŸ¥æ‰¾
TreeNode* bst_search(TreeNode *root, int data) {
    if (!root || root->data == data) {
        return root;
    }

    if (data < root->data) {
        return bst_search(root->left, data);
    } else {
        return bst_search(root->right, data);
    }
}

// è®¡ç®—æ ‘çš„é«˜åº¦
int tree_height(TreeNode *root) {
    if (!root) return 0;

    int left_height = tree_height(root->left);
    int right_height = tree_height(root->right);

    return 1 + (left_height > right_height ? left_height : right_height);
}

int main() {
    // æ„å»ºäºŒå‰æœç´¢æ ‘
    TreeNode *root = NULL;
    int values[] = {50, 30, 70, 20, 40, 60, 80};
    int n = sizeof(values) / sizeof(values[0]);

    printf("æ„å»ºäºŒå‰æœç´¢æ ‘ï¼Œæ’å…¥é¡ºåº: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", values[i]);
        root = bst_insert(root, values[i]);
    }
    printf("\n");

    printf("æ ‘çš„é«˜åº¦: %d\n", tree_height(root));

    printf("å…ˆåºéå†: ");
    preorder_traversal(root);
    printf("\n");

    printf("ä¸­åºéå†: ");
    inorder_traversal(root);
    printf("\n");

    printf("ååºéå†: ");
    postorder_traversal(root);
    printf("\n");

    printf("å±‚åºéå†: ");
    level_order_traversal(root);
    printf("\n");

    // æŸ¥æ‰¾æµ‹è¯•
    int search_value = 40;
    TreeNode *found = bst_search(root, search_value);
    if (found) {
        printf("æ‰¾åˆ°èŠ‚ç‚¹: %d\n", found->data);
    } else {
        printf("æœªæ‰¾åˆ°èŠ‚ç‚¹: %d\n", search_value);
    }

    return 0;
}
```

#### ç»å…¸æ’åºç®—æ³•
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

// å†’æ³¡æ’åº O(nÂ²)
void bubble_sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        if (!swapped) break; // ä¼˜åŒ–ï¼šå¦‚æœæ²¡æœ‰äº¤æ¢ï¼Œè¯´æ˜å·²æ’åº
    }
}

// é€‰æ‹©æ’åº O(nÂ²)
void selection_sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        if (min_idx != i) {
            int temp = arr[i];
            arr[i] = arr[min_idx];
            arr[min_idx] = temp;
        }
    }
}

// æ’å…¥æ’åº O(nÂ²)
void insertion_sort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

// å¿«é€Ÿæ’åº O(n log n)
int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;

    return i + 1;
}

void quick_sort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quick_sort(arr, low, pi - 1);
        quick_sort(arr, pi + 1, high);
    }
}

// å½’å¹¶æ’åº O(n log n)
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int *L = malloc(n1 * sizeof(int));
    int *R = malloc(n2 * sizeof(int));

    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }

    int i = 0, j = 0, k = left;

    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }

    while (i < n1) {
        arr[k++] = L[i++];
    }
    while (j < n2) {
        arr[k++] = R[j++];
    }

    free(L);
    free(R);
}

void merge_sort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        merge_sort(arr, left, mid);
        merge_sort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

// å †æ’åº O(n log n)
void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        heapify(arr, n, largest);
    }
}

void heap_sort(int arr[], int n) {
    // æ„å»ºæœ€å¤§å †
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // é€ä¸ªæå–å…ƒç´ 
    for (int i = n - 1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        heapify(arr, i, 0);
    }
}

// æµ‹è¯•æ’åºç®—æ³•æ€§èƒ½
void test_sort_performance() {
    const int sizes[] = {1000, 5000, 10000};
    const int num_sizes = sizeof(sizes) / sizeof(sizes[0]);

    printf("æ’åºç®—æ³•æ€§èƒ½æµ‹è¯•:\n");
    printf("ç®—æ³•\t\t1000\t5000\t10000\n");

    for (int s = 0; s < num_sizes; s++) {
        int n = sizes[s];
        int *original = malloc(n * sizeof(int));

        // ç”Ÿæˆéšæœºæ•°æ®
        srand(42); // å›ºå®šç§å­ä¿è¯ä¸€è‡´æ€§
        for (int i = 0; i < n; i++) {
            original[i] = rand() % 10000;
        }

        // æµ‹è¯•å„ç§æ’åºç®—æ³•
        struct {
            char name[20];
            void (*func)(int[], int);
        } sorts[] = {
            {"æ’å…¥æ’åº", insertion_sort},
            {"é€‰æ‹©æ’åº", selection_sort},
            {"å†’æ³¡æ’åº", bubble_sort}
        };

        if (s == 0) { // åªåœ¨ç¬¬ä¸€æ¬¡æ‰“å°ç®—æ³•å
            for (int i = 0; i < 3; i++) {
                printf("%s\t", sorts[i].name);

                int *arr = malloc(n * sizeof(int));
                memcpy(arr, original, n * sizeof(int));

                clock_t start = clock();
                sorts[i].func(arr, n);
                clock_t end = clock();

                double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000;
                printf("%.2fms\t", time_taken);

                free(arr);
            }
            printf("\n");
        }

        free(original);
    }

    // æµ‹è¯•é«˜æ•ˆç®—æ³•
    printf("\né«˜æ•ˆç®—æ³•æµ‹è¯• (10000ä¸ªå…ƒç´ ):\n");
    int n = 10000;
    int *original = malloc(n * sizeof(int));

    srand(42);
    for (int i = 0; i < n; i++) {
        original[i] = rand() % 10000;
    }

    struct {
        char name[20];
        void (*func)(int[], int, int);
    } efficient_sorts[] = {
        {"å¿«é€Ÿæ’åº", quick_sort},
        {"å½’å¹¶æ’åº", merge_sort},
        {"å †æ’åº", heap_sort}
    };

    for (int i = 0; i < 3; i++) {
        int *arr = malloc(n * sizeof(int));
        memcpy(arr, original, n * sizeof(int));

        clock_t start = clock();
        if (i == 0) { // å¿«é€Ÿæ’åº
            quick_sort(arr, 0, n - 1);
        } else if (i == 1) { // å½’å¹¶æ’åº
            merge_sort(arr, 0, n - 1);
        } else { // å †æ’åº
            heap_sort(arr, n);
        }
        clock_t end = clock();

        double time_taken = ((double)(end - start)) / CLOCKS_PER_SEC * 1000;
        printf("%s: %.2fms\n", efficient_sorts[i].name, time_taken);

        free(arr);
    }

    free(original);
}

int main() {
    test_sort_performance();
    return 0;
}
```

## âš¡ æ€§èƒ½ç‰¹ç‚¹

| æ•°æ®ç»“æ„ | æŸ¥æ‰¾ | æ’å…¥ | åˆ é™¤ | ç©ºé—´å¤æ‚åº¦ |
|----------|------|------|------|------------|
| æ•°ç»„ | O(1) | O(n) | O(n) | O(n) |
| é“¾è¡¨ | O(n) | O(1) | O(1) | O(n) |
| å“ˆå¸Œè¡¨ | O(1) | O(1) | O(1) | O(n) |
| äºŒå‰æœç´¢æ ‘ | O(log n) | O(log n) | O(log n) | O(n) |

| æ’åºç®—æ³• | æœ€å¥½ | å¹³å‡ | æœ€å | ç©ºé—´å¤æ‚åº¦ | ç¨³å®šæ€§ |
|----------|------|------|------|------------|--------|
| å†’æ³¡æ’åº | O(n) | O(nÂ²) | O(nÂ²) | O(1) | ç¨³å®š |
| é€‰æ‹©æ’åº | O(nÂ²) | O(nÂ²) | O(nÂ²) | O(1) | ä¸ç¨³å®š |
| æ’å…¥æ’åº | O(n) | O(nÂ²) | O(nÂ²) | O(1) | ç¨³å®š |
| å¿«é€Ÿæ’åº | O(n log n) | O(n log n) | O(nÂ²) | O(log n) | ä¸ç¨³å®š |
| å½’å¹¶æ’åº | O(n log n) | O(n log n) | O(n log n) | O(n) | ç¨³å®š |
| å †æ’åº | O(n log n) | O(n log n) | O(n log n) | O(1) | ä¸ç¨³å®š |

## ğŸ”— çŸ¥è¯†å…³è”

- **å‰ç½®çŸ¥è¯†**ï¼š[[ç¼–ç¨‹åŸºç¡€]] [[æ•°å­¦åŸºç¡€]]
- **ç›¸å…³æŠ€æœ¯**ï¼š[[ç®—æ³•è®¾è®¡]] [[æ•°æ®åº“åŸç†]]
- **å®æˆ˜åº”ç”¨**ï¼š[[ç®—æ³•ç«èµ›]] [[ç³»ç»Ÿè®¾è®¡]]
- **æ·±å…¥å­¦ä¹ **ï¼š[[é«˜çº§æ•°æ®ç»“æ„]] [[ç®—æ³•åˆ†æ]]

## ğŸ·ï¸ æ ‡ç­¾
#æ•°æ®ç»“æ„ #ç®—æ³• #ç¼–ç¨‹åŸºç¡€ #ç®—æ³•å¤æ‚åº¦ #æ’åºç®—æ³• #æ ‘ç»“æ„ #é¢è¯•é‡ç‚¹